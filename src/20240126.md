# January 26th 2024: Scheme Learning Resources

[<img src="https://img.youtube.com/vi/iC8eSdoyu9A/0.jpg" width="100%"/>](https://youtu.be/iC8eSdoyu9A)
Watch Will's video at [https://youtu.be/iC8eSdoyu9A](https://youtu.be/iC8eSdoyu9A)

~~~admonish info title='Words by Will E. Byrd'
The following is a (very) lightly edited version of the transcript of Will's video linked above. Links to
content mentioned have been located and included for further reading/viewing.
~~~

## Intro

Welcome to Episode IV of **Will's Guide**. This year, I've decided to make
1,024 videos - I've upped the number from a thousand, because I think two to the
tenth or one kiloTube of videos is more fun! 

I've also set up the Discord server, and we've had about a dozen people join. 
If you're interested in joining the Discord server *The Imperishable Wonderland of
Infinite Fun*, please email me.

Today, I'd like to talk about something close to my
heart: Scheme, a language which I love. And I'm just going to talk a little bit
about how you might learn Scheme. I'm going to have a whole bunch of videos on Scheme (I hope),
but how do you learn about Scheme? What are the resources available?
Let's just talk about a few of them I found useful..
<!-- 0:44 -->
### *The Little Schemer* by Dan Friedman and Matthias Felleisen
- [The Little Schemer (MIT Press)](https://mitpress.mit.edu/9780262560993/the-little-schemer/)
- [Dan's Wikipedia Entry](https://en.wikipedia.org/wiki/Daniel_P._Friedman)
- [Felleisen.org Site](https://felleisen.org/matthias/), [Matthias' Wikipedia](https://en.wikipedia.org/wiki/Matthias_Felleisen) and [Racket.org](https://racket-lang.org/)

One is called {{ii:The Little Schemer}} by {{i:Daniel P Friedman}} and 
{{i:Matthias Felleisen}}.
Dan was my adviser at Indiana University for my PhD, and he was also Matthias's adviser.
You also might know Matthias from the {{i:Racket}} world, so you have two experts guiding
you. 

This book is really about thinking computationally, and specifically thinking about *recursion* - recursion over
lists and trees - those sorts of things, and also a little interpreter work. So, if you think is is going to be a
book that's a big thick manual on Scheme - the programming language and the semantics or whatever - well, you might be
disappointed. But this really in another way is at the heart of thinking about Scheme computationally and thinking
about computation and recursion, so it's a great book to affect your thinking and
make sure that you're really comfortable with ideas about recursion. 

So this is recommended by me if you want to learn how to think recursively at least a certain way of thinking recursively. 
If you're not comfortable with recursion, if you read this book and if you learn Scheme in general, you're likely to become very
comfortable with recursion, because Scheme is really based on recursion. There's no loop constructs like there
are in most languages (or anything does look like a loop, it's actually tail recursion which we'll talk about later)..

So it's sort of the secret that Scheme doesn't really have loops in the way most languages do, although it turns out you
can implement loops that are equivalent to a certain type of recursion..

## The Structure and Interpretation of Computer Programs by Hal Abelson, Jerry and Julie Sussman
- [The Structure and Interpretation of Computer Programs](https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/index.html)

Another great resource is {{ii:The Structure and Interpretation of Computer
Programs}} by {{i:Harold Abelson}} and {{i:Gerald J Sussman}} with Julie
Sussman.  This is very famous as maybe the greatest textbook in the history of 
computer science - it was used as the introductory textbook at MIT for many
years. It has all sorts of interesting ideas about computation and interpreters - 
how to write interpreters, how you write a program that interprets another program, 
those sorts of ideas, computational models. Great book, full of deep fascinating ideas.

Once again not a manual on Scheme - Scheme is introduced as needed as a computational 
notation which really gets back to the heart of Lisp, the Lisp family of languages. You
need to have some sort of notation to talk about computation, so let's have a
very elegant, simple, minimal notation that's compositional, has nice properties,
and we can think about that's at the heart of Scheme, and that's one reason I really like
Scheme. 

## MIT 6.001 1986 Lecture Series 

[<img src="https://img.youtube.com/vi/-J_xL4IGhJA/0.jpg" width="100%"/>](https://www.youtube.com/embed/videoseries?si=QTCjrbRVLwYF_xsx&amp;list=PLE18841CABEA24090)

- [MIT 6.001 1986 Lectures on YouTube](https://www.youtube.com/playlist?list=PLE18841CABEA24090)

There's a series of videos based on the ideas in the books called the
{{ii:SICP Lectures}} and if you're interested in the book you
might like these videos. 

I will say that the videos can be - and the book can be - a little mathy, especially in terms of the 
examples. They aim towards the MIT entering class, or in this case, for these lectures I
don't know if these are supposed to be more experienced programmers or whatever, but it can turn
people off a little bit. So if you find that this is a little hard going, maybe start
with something like *The Little Schemer* first, which is really written for the bright high school student, 
but the ideas are very deep and powerful, and can benefit anyone. So maybe start with something
like *The Little Schemer*, and if you feel that's not enough, you could try {{ii:The Reasoned Schemer}} 
which is a much harder book, but in any case you could build yourself up towards the ideas in SICP
over time.

## Software Design for Flexibility by Chris Hanson and Jay Sussman

- [Software Design for Flexibility](https://mitpress.mit.edu/9780262045490/software-design-for-flexibility/)

There's a follow-on book - intellectually a follow-on book - called
{{ii:Software Design for Flexibility}}: *How to Avoid Programming Yourself into a Corner* by {{i:Chris Hanson}} and Gerald J Sussman. 
this is metaphorically the advanced version or the advanced follow-up of *Structure and Interpretation of Computer Programs*. 
It's really about how do you write software, how do you write complicated programs in such a way, that if you want to make a significant 
change to the program, you don't have to throw away all your code
and start over again, which turns out to be quite tricky. So the book uses a bunch
of techniques people in the Scheme and Lisp community, and AI communities, have
developed over a long period of time to make software more flexible. 

OK, so it's full of really interesting techniques should probably talk about that at some
point. Once again, not a book on Scheme but it contains a lot of really advanced
uses of Scheme - you can learn a lot by looking at this book.

## Simply Scheme: Introducing Computer Science by Brian Harvey and Matthew Wright

- [Simply Scheme: Introducing Computer Science](https://people.eecs.berkeley.edu/~bh/ss-toc2.html)

If you want something maybe closer to a
traditional textbook there's {{ii:Simply Scheme}} by Brian Harvey and Matthew
Wright. Now you can see the second edition is from 1999, so it's, you know, a quarter of a
century old - Scheme has changed and so forth, but the basic ideas will be similar.

So there there are some other introductory textbooks on Scheme.
You'll find most of them are kind of out of date in terms of the specific language features, 
but the important thing is how you think about the language. You can learn about the new variants of
Scheme over time.

## Scheme and Functional Programming Workshop

- [Scheme and Functional Programming Workshop](https://www.schemeworkshop.org/)

There are also a bunch of papers that you can you can find on Scheme. There's a {{ii:Scheme and Functional 
Programming Workshop}}, it's been held for a number of years, since 2000. Hopefully there'll be a 2024 one 
happening soon. I'm on the Steering Committee for this Workshop and I've organized it several times, so if 
you look at one of these workshops like from last year, you can find the Program and the Accepted
Papers, and this sort of thing. So here's a pre-print and you find this is a recorded talk, on "Designing a 
Language for Learning Continuations". 

You can find the video online - lots of good resources there. This is going to be more advanced, of 
course, than a textbook, but this is where a lot of the ideas get percolated - or more like
disseminated - through the community, is through papers or researchers talking to
each other. 

If you don't have access to researchers talking to each other, if you're not in grad school, if you're not a 
working academic, if you're not a Scheme implementer, then reading papers is probably the best thing to do.

## Lambda the Ultimate

- [Lambda the Ultimate (papers page)](http://lambda-the-ultimate.org/papers)

Certainly one of the best things to do now, because of the internet, and the web, there are lots and lots 
of videos you can watch and learn things that way as well. And of course, communicate with people via forums
and all the amazing things that we have now. Speaking of forums, you know
there's {{ii:Lambda the Ultimate}}, the Programming Languages Web Log, which used to be
more active. I don't know to what extent it is active these days, but there's a
period in time where this was a really important resource for people trying to understand functional
programming. And there's a group of papers here called Lambda the Ultimate papers, where the website got its name,
and you see *Lambda the Ultimate Imperative*, for example (Uh, I don't know what will happen if I try opening that, 
let's see how about that one yeah let's try it - I have no idea - oh, okay).. 

Well, anyway these are papers with {{i:Guy Steele}} and Jerry Sussman, these the original Lambda the Ultimate papers: 
Lambda the Ultimate "X". These are papers that were describing Scheme and using Scheme or using Lisp to solve
different types of problems and looking at Lips or Scheme from different perspectives, so these are classic papers.

"Introduction to Lambda Calculus," ok, "GOTO Statement Considered Harmful" by Dykstra, a whole bunch of interesting papers, 
"Essence of Compiling Continuations," so, you know, these are classic papers in functional programming, in programming languages, 
that are worth taking a look at, and many of these are involving Scheme or some version of Lisp.

## Scheme.org

- [Scheme.org](https://www.scheme.org/)

There's also this {{ii:scheme.org}} website, there at least used to be a website called "Read Scheme", I don't know if that
still exists, but you know Scheme's been around long enough that websites come
and go. The scheme.org website seems to have lots of useful resources, and you can see that there are different 
standards and implementations, and so forth, great things about Community, books...


## SchemeDoc Bibliography

- [SchemeDoc Bibliography](https://github.com/schemedoc/bibliography)

Here is a Scheme bibliography on GitHub and this lists all sorts of lambda
papers, and papers on macros (well maybe it doesn't... Like I said Scheme's been
around a long time, so I don't know why these things aren't working...) So, you know, there are 
lots and lots of papers on different topics like reflection, a bunch of really
interesting papers on reflection in Scheme, and we'll talk about those too.

## R5RS, R6RS, R7RS Pages

- [R5RS Page](https://conservatory.scheme.org/schemers/Documents/Standards/R5RS/)
- [R5RS Standard PDF](https://conservatory.scheme.org/schemers/Documents/Standards/R5RS/r5rs.pdf)
- [R6RS.org](https://www.r6rs.org/)
- [R7RS.org](https://www.r7rs.org/)

All right, another way if you really want to learn Scheme, is to start looking
at the standards - like R5RS: that's the *Revised Revised Revised Revised Revised
Report on the Algorithmic Language Scheme*, so there's this tradition of
having "Revised" repeated a bunch of times, so R6RS - add one more "Revised" at the
beginning, so be Revised to the sixth power. 

R7RS, which is the standard currently being developed has "Revised" to the
seventh power so that's if you hear people talk about R5RS, R6RS,
they might just call it R6, they're talking about different versions of the Scheme specification
standard. R5RS was the standard that was in place when I started graduate
school, and when I started studying Scheme in a serious way. 

Normally you hear about people talking about R4RS, R5RS, R6RS, R7RS. R7RS is broken into
two parts - a "large" and a "small" - but those are the standard things you hear
about, so if someone's talking about R5RS Scheme, that's what they're referring to - they're referring to 
that version of Scheme. 

And you can get the report which is pretty short - it's 50 pages long - this
is a beautiful document, the R5 document, oh I love it, one of my favorite
documents in computation. And you know, it has an index, it has a denotational semantics which has some problems, 
but it contains a complete semantics for the programming language, and an
index and descriptions of the core features of language, and the syntax, and all that, and examples, and the whole
thing's 50 pages long! 

So you can read 50 pages, it's not that long, there'll be things you don't understand, but there'll
be lots of things you do understand, because this is written actually very well, and if you take a Scheme
interpreter, or Scheme compiler, and you try going through the examples
with your Scheme compiler, you can get a lot of mileage, just from reading through this
document.

More recently, there's the *Revised Revised Revised Revised Revised Revised* (I think I got that right) *Report on the
Algorithmic Language Scheme* Revised to the sixth power or R6RS, and you can find it on R6RS.org. There are different 
versions of the specification. Now for R6, they broke up the specification into both the language
specification, and the standard libraries, so this is a bigger version of Scheme, significantly bigger than R5RS. 

It's somewhat controversial that it was so big. Now, compared to a language like Java, it's tiny, but it's still much bigger
than R5, which was bigger than R4, and there are some people in the Scheme community who love the tiny tiny tiny
core language that's easy to implement, easy to teach, easy to understand, and there's some people who want a pragmatic
practical language for everyday programming practical tasks - they want a bigger language. In R6, they
found something of a middle ground, that didn't make everyone happy. Maybe it made
no one happy! But that was the approach taken for R6, and so they broke the standard libraries into a different
document, and they also have these Non-normative Appendices, and Rationale.

This is great if you want to understand how a language is designed, so this is a
discussion about *why* they did certain things. Ok, so not only is there a a
specification, and in this case a different type of semantics, this I believe is operational semantics, but
they also talk about why they made these decisions. I think that's pretty
interesting. 

Now, if you want to get your hands on a specification, and understand it, what I probably would recommend is starting with R5, 
just because it's so small. R5RS doesn't really describe things like hygienic macros in a lot of depth and there 
are some things that are frankly mistakes in or or oversights in the spec, so I wouldn't say
that this is the final word, even for the R5 version. However, it's so small and
it's so well written, that I think it's a great way to get a handle on what a spec
looks like. 

Or you could just dive into R6, but just be aware that the this is a bigger language and and specifies a lot more,
and this libraries part is large as well. 

So, ok, and then there's an R7RS, which I was talking about which is still being developed. There's a "small" language 
and a "large" language. So like I said, there was some controversy over R6RS, because it was a
bigger standard than R5, and yet it didn't include things like threads, it didn't include lots of information about dealing 
with the operating system and the web. So people who wanted to use Scheme as a a teaching language,
or as a language where they could easily hack up an implementation and play around with ideas - that way - some of those people 
weren't so happy with R6, because it was bigger and more complicated than R5, harder to implement, harder to teach... 
And at the same time, people who want to do web programming, let's say, or create a video game in Scheme, 
and interact with graphics or whatever complicated thing, they weren't happy, because R6RS didn't specify that.

But what R6RS *did* specify was a library system where people could (at least in
theory) write code that could be modularized, and maybe ported between different implementations. Before R6RS, there really wasn't 
a chance to port code easily between Scheme implementations so R6 was a step in that direction. 

And R7RS is a reaction to some extent (I think) against R6 where they say: "Ok, let's have a small language for the people 
who want a tiny jewel-like gem of a language, that's easy to implement, easy to understand, they can
hack it to their heart's content for, you know, programming languages research, or whatever they want to do; they can
have the small language". 

And for the people who want to have a really big language, they have the big language. So
they split up the spec, which is an interesting idea. What's happened in practice is that
the small language design was completed in 2013. The large language design is
still going on, so, 11 years after the small language was finished, and I
guess this was sort of, almost a guaranteed outcome when you're trying
to make a much bigger version of the language, that's not supported by a
bunch of industry, and government research labs or whatever...

So this spec is still going on. You will see for any individual Scheme
implementation, it's likely to say which version of the spec is supported: 
they support R4RS, they support R5RS, R6, R7, "R7 small". 

Nothing supports "R7 large" completely because that spec is still
being developed... 

Scheme currently supports R6RS, and even for something like R6RS or R5RS, 
you'll often see that an individual implementation will describe differences
from the spec. So in fact, for some versions of the specification, the
specification itself is internally inconsistent, and it's impossible to implement
a correct version, or at least people have made that argument: that it's impossible to create 
a fully conforming
implementation...

Also there are some subtleties in the spec that make a little bit of a design and 
implementation tradeoff. To decide to implement every single thing in the spec so many 
implementations will say they Implement RNRS whatever N is, modulo this one little feature... 

Ok, so those are the the language specs and it's really important if
you're going to use Scheme, or any other language, to be comfortable with the
definition of the language. 

I think a nice thing about Scheme is this the the specification is actually pretty
small - if you want to learn C++ or Java those specifications are quite
complicated although C++ they seem to be (maybe) simplifying. Java still seems to be
getting more complicated in a way, although they are adding abstractions that hopefully are
helpful.

## The Scheme Programming Language by R. Kent Dybvig

- [The Scheme Programming Language](https://scheme.com/tspl4/)

## The Chez Scheme User's Guide

- [The Chez Scheme User's Guide](https://cisco.github.io/ChezScheme/csug9.6/csug.html)

## Chez Scheme on Github

- [Chez Scheme on Github](https://cisco.github.io/ChezScheme/)
- [Chez Scheme Github Repo](https://github.com/cisco/chezscheme)

## Scheme Related Papers by CollectRobot

- [Scheme Related Papers by CollectRobot](https://github.com/collectrobot/SchemeRelatedPapers)
- [How to Debug Scheme Programs](https://github.com/collectrobot/SchemeRelatedPapers/blob/master/doc/How%20to%20Debug%20Chez%20Scheme%20Programs.md)
- [Generation-Friendly Eq Hash Tables](https://www.schemeworkshop.org/2007/procPaper3.pdf)

<!--

 okay another way to learn about scheme is to read this book this is a
21:17
book I refer to all the time which is called the scheme programming language fourth edition by Kent diig who's
21:23
creator of sha scheme and who also was the editor of
21:30
r6rs uh that spec and so this is describing in the fourth edition um you
21:36
know basically r6rs scheme but instead of describing it in a very formal way it
21:43
is describing scheme you know from the standpoint of examples and
21:50
motivation and uh gives just gives a lot more detail so this is you know it's not
21:55
it's not really a textbook or tutorial alth although it has aspects of that um you know if you didn't know how to
22:01
program at all I think this would be a hard book to learn programming from but it's a great book to go to to try to
22:10
understand what the specification is trying to say so if there's part of r6rs that's complicated
22:16
or you just don't know about a feature at all if you read about it in this book
22:22
and then look at the spec then look at r6rs then that will give you much better
22:28
idea of what's going on and since Kent you know was um the editor for for the
22:36
r6rs process he understands what the motivation was and he's also an implementer so he knows inside and out
22:44
not just the motivation from the specification process but how at least
22:49
Shay scheme implements um those parts of the language or at least how how Shay
22:55
scheme implemented it when he wrote This Book very very useful resource the book's
23:01
very well written another companion guide that
23:07
goes to that is the Shay scheme users guide so like I said Kent diig is a
23:13
creator of sha scheme and he has a users guide which now uh I guess other people
23:20
have contributed um maybe to this guide certainly originally I think this was written by Kent and it ties to
23:28
the scheme programming language book these are cross referenced with each other very helpful so if you're using sh
23:34
scheme which is the implementation along with racket that I use most
23:39
often of of scheme or scheme like language then this is a very helpful
23:45
guide and because it cross references with this uh book talking about r6rs you
23:53
can learn a lot about the language the spec and about how Shay does things and
23:59
where Shay differs from the specification so two really useful
24:04
resources one thing that's changed since when I started grad school let's say at
24:10
Indiana was that sha scheme which is always been known as a highquality scheme implementation used to be
24:18
commercial software that you had to pay an expensive license to be able to
24:24
run uh Cisco ended up purchasing sha scheme and
24:29
getting um Kent and other sheay hackers uh to work with them on a project for a
24:36
number of years so you can see that this users guide is actually from Cisco and
24:41
Cisco eventually released Shay scheme Version 9 as open source software under
24:48
an open source license so now you can run the full version of shaem the full compiled version whereas before you
24:54
could only use The Interpreter and Shas schem is now available on GitHub so I
25:01
use sha scheme a lot and will'll be using Shay scheme at least some of these videos and so here you can see the Cisco
25:09
dogubayazit
25:27
night when I Was preparing for a video or preparing to make a bunch of videos I
25:34
started going through some of this documentation in the Sha scheme uh guide
25:40
and in particular I wanted to learn how to use a sha scheme debugger better sh scheme has an integrated debugger it
25:46
also has tracing facilities all sorts of nice features but I've never really been
25:52
comfortable using debugger partly because when I was in grad school the debugger didn't work that well because I
25:58
only had access to The Interpreter not the compiler the debugger really is much
26:03
better if you had the compiler for a Shas gem which I have access to now because it's open source so I want to go
26:09
back and learn about the debugger when I was reading the debugging section I noticed that well
26:16
probably because this was written 10 10 or more years ago maybe 15 years ago now
26:23
um there's this dead link to how to debug Shay scheme programs for fortunately someone has uh you know
26:32
found Kent's instructions on how to debug sha scheme programs and you can find it online for
26:39
GitHub and I found some other little typos I think this is a typo Trace let
26:44
may be used to trace ordinary Le Expressions as well as Le Expressions that I think is a typo I
26:52
don't know a little confused here's something looks like a copy and paste
26:57
error box inspector objects box inspector objects contain sha scheme boxes okay and then TLC inspector
27:04
objects box inspector objects contain Shay scheme boxers boxes that looks like a copy and paste error to me and I
27:12
didn't even know by the way what a TLC inspector object was i' never heard of that it looks like that's coming from
27:19
this paper um my friend disease galom and Kent wrote on um generation friendly
27:26
EQ table so scheme EQ is pointer equality generation friendly has to do
27:32
with generational garbage collection I mean we talk about that um but it turns
27:40
out that these TLC things are temp transport link cells I never heard of
27:45
that term before um has to do with the way they Implement these hash tables so this documentation is a transport link
27:53
cell inspector object I think there's just a little copy and paste mistake and uh I think I found one or
28:02
two other typos because sha scheme is now you know
28:09
open source and you can find um not just the code for sha scheme but also the Sha
28:16
scheme users guide and along with that you know the
28:21
scheme programming language fourth edition all these files are here we can go and we can look at the bug
28:30
um which is like a scheme version of tech I believe that Kent came up with
28:35
this is like a scheme Tech and it turns out that sure enough uh these typos what
28:42
I believe are typos are or old URLs are in the documentation and I don't know if Kent's
28:49
still maintaining this or not but there are people still working on Sha scheme and and in particular the racket people
28:56
are rebuilding they've rebuilt racket on top of Shay so they're active in keeping
29:01
Shay up to date and then some of the people who worked on Shay at Cisco like
29:07
Andy keep or are still you know keeping an eye on it and making updates so I
29:13
emailed Andy to ask um what should I do should I do a poll request or you know
29:19
send him or someone else the typos I've found so that especially when you're
29:25
part of a small community but reading books as well is a service that I think is important so not only you know do you
29:33
hopefully uh feel comfortable reading specifications and reading formal
29:39
documentation reading books but if you find an error it's really helpful to the
29:45
authors if you could report that error somehow so that's what I'm going to do to try to be a good citizen in uh the
29:53
Shay scheme world to try to report these little uh typos you know there's nothing
29:59
here I couldn't easily understand so I don't think it's a any sort of deep error but let's go ahead and you know
30:05
try to correct all those so if you're reading documentation and you think
30:10
something's an error now if you don't know the language well if you don't know the documentation well then maybe it's
30:17
hard to tell so maybe ask someone else first but if you're pretty sure it's just a typo maybe go ahead and email the
30:24
person who created it or send a poll request and that's one way we can try to
30:32
make these languages and documentation and tutorials books uh better over
30:40
time so that is just a quick overview of
30:46
some resources for learning scheme and you know the importance I
30:51
think of learning spec you know from the uh official specification trying to read
30:57
those the scheme spec is very short so if you're interested in scheme I
31:03
recommend maybe starting with r five or just starting with r six you could do r
31:08
s small and trying to trying to read those specs you could read all of them if you if you're really into it trying
31:15
to see how far you can get understanding it and in the intro to R5 and I don't
31:21
know how how old this intro is there's this marvelous
31:28
philosophical statement about the design of scheme how the the philosophy behind
31:34
scheme's design you know in particular I love this sentence programming languages should be designed not by piling feature
31:41
on top of feature but by removing the weaknesses and restrictions that make
31:46
additional features appear necessary I love it scheme demonstrates
31:52
a very small number of rules for forming expressions with no restrictions on how they or compos suffice to form a
32:00
practical and efficient programming language that is flexible enough to support most of the major programming
32:05
paradigms in use today oh very strong sense of design I love it this is very
32:11
different from say the design of java okay very
32:17
different um so it's interesting when you're learning languages or thinking about languages comp you know compare
32:23
and contrast the philosophies of language and then the languages change over time are they you know are they
32:32
keeping up with this philosophy or are they changing somehow I think certainly through R5 scheme had this philosophy
32:40
some people I think said that R six maybe went too far away from being this
32:45
minimum language with the smallest number of features R seven small is more
32:51
like this philosophy whether or not the larger versions are more useful
32:58
that's an interesting question any case um I hope you will take a look at the R5
33:05
report and see if you can make sense of that parts of it are very easy to read
33:11
parts of it are kind of complicated and if you're not familiar with denotational semantics well it's going to be really
33:16
hard to read if uh you don't know anything about hygienic scheme macros going to be hard to read but we can talk
33:22
about some of those topics in these videos all right see you soon I got
33:28
1,020 videos to make bye-bye

-->
